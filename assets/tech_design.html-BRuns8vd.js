import{_ as o,c as d,o as t,e as c}from"./app-Ne0PdyYx.js";const r="/assets/process-D1R7I7gn.png",n="/assets/plugin_framework-BfgmHjNn.png",i={};function l(a,e){return t(),d("div",null,e[0]||(e[0]=[c('<h2 id="插件化进程模型" tabindex="-1"><a class="header-anchor" href="#插件化进程模型" aria-hidden="true">#</a> 插件化进程模型</h2><p>如下图示，<code>PluginCore</code>进程模型包括<code>Plugin Space</code>、<code>Plugin Framework</code>、和<code>Plugin Native</code>等层级，以实现系统隔离和请求修改等功能。</p><p align="center"><img src="'+r+'" alt="plugin_framework" width="500"></p><h2 id="插件化框架架构" tabindex="-1"><a class="header-anchor" href="#插件化框架架构" aria-hidden="true">#</a> 插件化框架架构</h2><table><thead><tr><th style="text-align:left;">框架层级</th><th style="text-align:left;">主要工作</th></tr></thead><tbody><tr><td style="text-align:left;">Plugin Space</td><td style="text-align:left;">由<code>PluginCore</code>提供了一个内部的空间，用于安装要在其内部运行的APP，这个空间是系统隔离的。</td></tr><tr><td style="text-align:left;">Plugin Framework</td><td style="text-align:left;">这一层主要给<code>Android Framework</code>和<code>PluginCore</code>做代理，这也是<code>PluginCore</code>的核心。<code>PluginCore</code>提供了一套自己的<code>PluginCore Framework</code>，处于<code>Android Framework</code>与<code>PluginCore APP</code>之间。对于<code>PluginCore</code>，其访问的所有系统<code>Service</code>均已被 <code>PluginCore Framework</code> 代理，它会修改<code>PluginCore</code>的请求参数，将其中与<code>PluginCore</code>安装信息相关的全部参数修改为宿主的参数之后发送给<code>Android Framework</code>（有部分请求会发送给自己的<code>PluginCore Server</code>直接处理而不再发送给<code>Android</code>系统）。这样<code>Android Framework</code>收到<code>PluginCore</code>请求后检查参数就会认为没有问题。待<code>Android</code>系统对该请求处理完成返回结果时，<code>PluginCore Framework</code>同样也会拦截住该返回结果，此时再将原来修改过的参数全部还原为<code>PluginCore</code>请求时发送的。这样<code>PluginCore</code>与<code>Android</code>系统的交互也就能跑通了。</td></tr><tr><td style="text-align:left;">Plugin Native</td><td style="text-align:left;">在这一层主要为了完成2个工作，IO重定向和<code>PluginCore APP</code>与<code>Android</code>系统交互的请求修改。IO重定向是因为可能有部分APP会通过写死的绝对路径访问，但是如果APP没有安装到系统，这个路径是不存在的，通过IO重定向，则将其转向<code>PluginCore</code>内部安装的路径。另外有部分jni函数在<code>PluginCore Framework</code>中无法<code>hook</code>的，所以需要在<code>native</code>层来做<code>hook</code>。</td></tr></tbody></table><p align="center"><img src="'+n+'" alt="plugin_framework" width="500"></p>',6)]))}const s=o(i,[["render",l],["__file","tech_design.html.vue"]]);export{s as default};
