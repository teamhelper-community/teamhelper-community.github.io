import{_ as e,c as a,o as s,e as t}from"./app-Ne0PdyYx.js";const i={};function o(l,n){return s(),a("div",null,n[0]||(n[0]=[t(`<h2 id="_1-对外暴露的接口说明" tabindex="-1"><a class="header-anchor" href="#_1-对外暴露的接口说明" aria-hidden="true">#</a> 1. 对外暴露的接口说明</h2><p>SDK 通过 <code>RPC</code> 对象对外提供所有 IPC/RPC 通信接口。下文对各个接口进行详细说明：</p><h3 id="_1-1-事件监听接口" tabindex="-1"><a class="header-anchor" href="#_1-1-事件监听接口" aria-hidden="true">#</a> 1.1 事件监听接口</h3><h4 id="_1-1-1-launcher-事件监听" tabindex="-1"><a class="header-anchor" href="#_1-1-1-launcher-事件监听" aria-hidden="true">#</a> 1.1.1 Launcher 事件监听</h4><p>用于监听子应用发送给 Launcher 的消息：</p><ul><li><strong>接口定义：</strong> <code>interface LauncherEventListener</code><ul><li><code>onTextEventReceived(event: Packet&lt;RpcData&gt;)</code> Json 协议消息体回调，参数为解析后的 JSON 消息对象。</li><li><code>onBinaryEventReceived(event: RPCProto.Packet)</code> Protobuf 协议消息体回调，参数为解析后的二进制消息对象。</li></ul></li></ul><h4 id="_1-1-2-plugin-事件监听" tabindex="-1"><a class="header-anchor" href="#_1-1-2-plugin-事件监听" aria-hidden="true">#</a> 1.1.2 Plugin 事件监听</h4><p>用于监听子应用之间的消息传递，当设备离线时，Launcher 可缓存消息，待目标应用上线后再发送：</p><ul><li><strong>接口定义：</strong> <code>interface PluginEventListener</code><ul><li><code>onTextEventReceived(event: Packet&lt;RpcData&gt;, offline: Boolean)</code> Json 协议消息体回调，并附带离线状态标识。</li><li><code>onBinaryEventReceived(event: RPCProto.Packet, offline: Boolean)</code> Protobuf 协议消息体回调，并附带离线状态标识。</li></ul></li></ul><h4 id="_1-1-3-客户端连接监听" tabindex="-1"><a class="header-anchor" href="#_1-1-3-客户端连接监听" aria-hidden="true">#</a> 1.1.3 客户端连接监听</h4><p>用于监听局域网内与 Launcher Socket Server 的设备上线、下线事件：</p><ul><li><strong>接口定义：</strong> <code>interface ClientConnectionListener</code><ul><li><code>online(ip: String, deviceId: String, platform: String, pkg: String, version: Int)</code> 设备上线回调。</li><li><code>offline(ip: String, deviceId: String, platform: String, pkg: String, version: Int)</code> 设备下线回调。</li></ul></li></ul><h4 id="_1-1-4-事件监听管理" tabindex="-1"><a class="header-anchor" href="#_1-1-4-事件监听管理" aria-hidden="true">#</a> 1.1.4 事件监听管理</h4><p>SDK 提供添加和移除各类事件监听器的接口：</p><ul><li><p><strong>添加/移除 Launcher 事件监听：</strong></p><ul><li><code>fun addLauncherEventListener(listener: LauncherEventListener)</code></li><li><code>fun removeLauncherEventListener(listener: LauncherEventListener)</code></li></ul></li><li><p><strong>添加/移除 Plugin 事件监听：</strong></p><ul><li><code>fun addPluginEventListener(listener: PluginEventListener)</code></li><li><code>fun removePluginEventListener(listener: PluginEventListener)</code></li></ul></li><li><p><strong>添加/移除客户端连接监听：</strong></p><ul><li><code>fun addClientConnectionListener(listener: ClientConnectionListener)</code></li><li><code>fun removeClientConnectionListener(listener: ClientConnectionListener)</code></li></ul></li></ul><h3 id="_1-2-消息发送接口" tabindex="-1"><a class="header-anchor" href="#_1-2-消息发送接口" aria-hidden="true">#</a> 1.2 消息发送接口</h3><p>SDK 提供多种消息发送方式，支持 IPC 与 RPC 两种通信场景。</p><h4 id="_1-2-1-rpc-消息发送" tabindex="-1"><a class="header-anchor" href="#_1-2-1-rpc-消息发送" aria-hidden="true">#</a> 1.2.1 RPC 消息发送</h4><p>适用于 Launcher 发送消息给指定设备或应用（局域网内通信）。</p><ul><li><p><strong>Text 模式（JSON 格式）</strong></p><ul><li>方法：<code>fun sendRpcEvent(targetDeviceId: String, targetPkg: String, data: String)</code></li><li>说明：通过 native 方法发送 JSON 格式的 RPC 消息给指定设备。</li></ul></li><li><p><strong>Binary 模式（Protobuf 格式）</strong></p><ul><li>方法：<code>fun sendRpcEvent(_targetDeviceId: String, _targetPkg: String, _data: ByteArray)</code></li><li>说明：通过 native 方法发送 Protobuf 格式的 RPC 消息给指定设备。</li></ul></li></ul><h4 id="_1-2-2-ipc-消息发送" tabindex="-1"><a class="header-anchor" href="#_1-2-2-ipc-消息发送" aria-hidden="true">#</a> 1.2.2 IPC 消息发送</h4><p>适用于 Launcher 内部或本机进程间通信。</p><ul><li><p><strong>Text 模式（JSON 格式）</strong></p><ul><li>方法：<code>fun sendIpcEvent(targetPkg: String, data: String)</code></li><li>说明：发送 JSON 格式的 IPC 消息给指定应用，消息发送者为当前设备。</li></ul></li><li><p><strong>Binary 模式（Protobuf 格式）</strong></p><ul><li>方法：<code>fun sendIpcEvent(_targetPkg: String, _data: ByteArray)</code></li><li>说明：发送 Protobuf 格式的 IPC 消息给指定应用。</li></ul></li></ul><h4 id="_1-2-3-消息转发接口" tabindex="-1"><a class="header-anchor" href="#_1-2-3-消息转发接口" aria-hidden="true">#</a> 1.2.3 消息转发接口</h4><p>用于 Launcher 转发插件应用的消息给其他目标应用，支持 IPC 场景下的消息中继。</p><ul><li><p><strong>Text 模式（JSON 格式）</strong></p><ul><li>方法：<code>fun transferIpcEvent(sourcePkg: String, sourceDeviceId: String, targetPkg: String, data: String)</code></li><li>说明：转发 JSON 格式消息，包含源应用信息与目标应用信息。</li></ul></li><li><p><strong>Binary 模式（Protobuf 格式）</strong></p><ul><li>方法：<code>fun transferIpcEvent(sourcePkg: String, sourceDeviceId: String, _targetPkg: String, _data: ByteArray)</code></li><li>说明：转发 Protobuf 格式消息，包含源应用信息与目标应用信息。</li></ul></li></ul><h3 id="_1-3-系统信息接口" tabindex="-1"><a class="header-anchor" href="#_1-3-系统信息接口" aria-hidden="true">#</a> 1.3 系统信息接口</h3><p>获取设备相关信息，便于业务逻辑中进行设备标识与应用识别。</p><ul><li><strong>获取自身设备 ID</strong><ul><li>方法：<code>fun getSelfDeviceId(): String</code></li></ul></li><li><strong>获取当前包名</strong><ul><li>方法：<code>fun getSelfPackageName(): String</code></li></ul></li></ul><h3 id="_1-4-内部消息分发" tabindex="-1"><a class="header-anchor" href="#_1-4-内部消息分发" aria-hidden="true">#</a> 1.4 内部消息分发</h3><p>SDK 内部通过 native 方法接收来自底层的事件，并调用以下分发方法，将消息分发给相应的事件监听器：</p><ul><li><strong>执行 Launcher 文本/二进制事件：</strong><br> 内部方法 <code>executeLauncherTextEvent(event: String)</code> 与 <code>executeLauncherBinaryEvent(event: ByteArray)</code></li><li><strong>执行 Plugin 文本/二进制事件：</strong><br> 内部方法 <code>executePluginTextEvent(event: String, offline: Boolean)</code> 与 <code>executePluginBinaryEvent(event: ByteArray, offline: Boolean)</code></li><li><strong>执行设备上线/下线事件：</strong><br> 内部方法 <code>executeOnline(...)</code> 与 <code>executeOffline(...)</code></li></ul><p>这些方法由 native 层调用，开发者无需直接调用。</p><hr><h2 id="_2-使用示例" tabindex="-1"><a class="header-anchor" href="#_2-使用示例" aria-hidden="true">#</a> 2. 使用示例</h2><p>下面给出一个简单的示例，说明如何在 Launcher 中集成 Bridge SDK 并使用 RPC/IPC 接口进行消息通信：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">import</span> com<span class="token punctuation">.</span>teamhelper<span class="token punctuation">.</span>bridge<span class="token punctuation">.</span>host<span class="token punctuation">.</span>RPC
<span class="token keyword">import</span> com<span class="token punctuation">.</span>teamhelper<span class="token punctuation">.</span>bridge<span class="token punctuation">.</span>host<span class="token punctuation">.</span>RPC<span class="token punctuation">.</span>LauncherEventListener
<span class="token keyword">import</span> com<span class="token punctuation">.</span>teamhelper<span class="token punctuation">.</span>bridge<span class="token punctuation">.</span>host<span class="token punctuation">.</span>RPC<span class="token punctuation">.</span>PluginEventListener
<span class="token keyword">import</span> com<span class="token punctuation">.</span>teamhelper<span class="token punctuation">.</span>bridge<span class="token punctuation">.</span>host<span class="token punctuation">.</span>RPC<span class="token punctuation">.</span>ClientConnectionListener

<span class="token comment">// 示例：添加 Launcher 级别的 RPC 事件监听</span>
RPC<span class="token punctuation">.</span><span class="token function">addLauncherEventListener</span><span class="token punctuation">(</span><span class="token keyword">object</span> <span class="token operator">:</span> LauncherEventListener <span class="token punctuation">{</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onTextEventReceived</span><span class="token punctuation">(</span>event<span class="token operator">:</span> Packet<span class="token operator">&lt;</span>RpcData<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 处理 JSON 消息</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Launcher 接收到文本消息: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span><span class="token expression">event<span class="token punctuation">.</span>data</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onBinaryEventReceived</span><span class="token punctuation">(</span>event<span class="token operator">:</span> RPCProto<span class="token punctuation">.</span>Packet<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 处理 Protobuf 消息</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Launcher 接收到二进制消息, 长度: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span><span class="token expression">event<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>size</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 示例：发送 RPC 文本消息给指定设备（局域网内通信）</span>
<span class="token keyword">fun</span> <span class="token function">sendRpcTextMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> targetDeviceId <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;device123&quot;</span></span>
    <span class="token keyword">val</span> targetPkg <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;com.example.targetapp&quot;</span></span>
    <span class="token keyword">val</span> jsonData <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;{\\&quot;command\\&quot;: \\&quot;doSomething\\&quot;}&quot;</span></span>
    RPC<span class="token punctuation">.</span><span class="token function">sendRpcEvent</span><span class="token punctuation">(</span>targetDeviceId<span class="token punctuation">,</span> targetPkg<span class="token punctuation">,</span> jsonData<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 示例：本机进程间 IPC 通信，发送 Protobuf 消息</span>
<span class="token keyword">fun</span> <span class="token function">sendIpcBinaryMessage</span><span class="token punctuation">(</span>protobufData<span class="token operator">:</span> ByteArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> targetPkg <span class="token operator">=</span> <span class="token string-literal singleline"><span class="token string">&quot;com.example.anotherapp&quot;</span></span>
    RPC<span class="token punctuation">.</span><span class="token function">sendIpcEvent</span><span class="token punctuation">(</span>targetPkg<span class="token punctuation">,</span> protobufData<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_3-注意事项" tabindex="-1"><a class="header-anchor" href="#_3-注意事项" aria-hidden="true">#</a> 3. 注意事项</h2><ul><li><strong>协议模式选择</strong>：根据业务需求选择 Text（JSON）或 Binary（Protobuf）模式；不同格式对应的接口调用略有区别。</li><li><strong>事件监听管理</strong>：请在合适的生命周期中添加并移除事件监听器，避免内存泄漏或重复处理消息。</li><li><strong>设备信息获取</strong>：通过 <code>getSelfDeviceId()</code> 与 <code>getSelfPackageName()</code> 获取当前设备标识，确保消息发送与接收时的准确匹配。</li><li><strong>扩展预留</strong>：Bridge SDK 的设计预留了未来扩展 RPC 通信及跨设备互联的能力，开发者可关注后续版本更新以获得更多功能支持。</li></ul>`,40)]))}const p=e(i,[["render",o],["__file","bridge_api.html.vue"]]);export{p as default};
