import{_ as s,c as a,o as t,e as i}from"./app-Ne0PdyYx.js";const e={};function o(l,n){return t(),a("div",null,n[0]||(n[0]=[i(`<h2 id="_1-客户端-sdk-概述" tabindex="-1"><a class="header-anchor" href="#_1-客户端-sdk-概述" aria-hidden="true">#</a> 1. 客户端 SDK 概述</h2><p>客户端 SDK 主要负责以下功能：</p><ul><li><strong>用户登录与登出</strong>：在 Launcher 登录成功后调用 <code>login</code> 接口连接 TPNS 服务器，在退出登录时调用 <code>logout</code> 以停止消息推送。</li><li><strong>消息订阅管理</strong>：当插件应用安装或卸载时，分别调用 <code>subscribeNotification</code> 和 <code>unsubscribeNotification</code> 接口，动态更新已安装的应用包列表。</li><li><strong>通知消息操作</strong>：提供对接收到的通知消息进行数据存储、读取、分页查询及标记已读等操作，通过 <code>NotificationUseCase</code> 实现。</li><li><strong>报文操作</strong>：提供对 TPNS 协议报文的存储、重发与删除操作，主要面向 SDK 内部使用，用户一般无需直接调用，通过 <code>ProtocolUseCase</code> 提供相关功能。</li><li><strong>通知监听</strong>：通过添加或移除通知监听器，实现对通知消息的实时监听与处理。</li></ul><hr><h2 id="_2-客户端-sdk-集成方式" tabindex="-1"><a class="header-anchor" href="#_2-客户端-sdk-集成方式" aria-hidden="true">#</a> 2. 客户端 SDK 集成方式</h2><p>为了将 TPNS 客户端 SDK 集成到您的项目中，请按照以下步骤配置仓库和依赖：</p><h3 id="_2-1-添加-maven-仓库" tabindex="-1"><a class="header-anchor" href="#_2-1-添加-maven-仓库" aria-hidden="true">#</a> 2.1 添加 Maven 仓库</h3><p>在项目的构建脚本中（如 Gradle 的 <code>build.gradle</code> 文件），添加以下 Maven 仓库配置：</p><div class="language-groovy line-numbers-mode" data-ext="groovy"><pre class="language-groovy"><code>maven <span class="token punctuation">{</span>
    url <span class="token interpolation-string"><span class="token string">&quot;http://maven.teamhelper.cn:8081/repository/MST/&quot;</span></span>
    isAllowInsecureProtocol <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-2-添加依赖" tabindex="-1"><a class="header-anchor" href="#_2-2-添加依赖" aria-hidden="true">#</a> 2.2 添加依赖</h3><p>在您的依赖配置中加入以下实现依赖：</p><div class="language-groovy line-numbers-mode" data-ext="groovy"><pre class="language-groovy"><code>implementation <span class="token interpolation-string"><span class="token string">&quot;com.teamhelper.xr:glass-bridge-host:0.0.17&quot;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>完成上述配置后，即可在项目中使用 TPNS 客户端 SDK 的相关接口。</p><hr><h2 id="_3-tpns-客户端-sdk-接口说明" tabindex="-1"><a class="header-anchor" href="#_3-tpns-客户端-sdk-接口说明" aria-hidden="true">#</a> 3. TPNS 客户端 SDK 接口说明</h2><p>客户端 SDK 对外暴露的主要接口位于 <code>TPNS.kt</code> 中，具体如下：</p><h3 id="_3-1-登录与登出" tabindex="-1"><a class="header-anchor" href="#_3-1-登录与登出" aria-hidden="true">#</a> 3.1 登录与登出</h3><ul><li><p><strong>登录</strong></p><ul><li><strong>方法</strong>：<code>fun login(userId: Long, appKey: String, code: String, installedPkgsList: List&lt;String&gt;)</code></li><li><strong>说明</strong>：在 Launcher 登录成功后调用，用于连接 TPNS 服务器。参数包括用户 ID、应用appKey、连接授权码 以及设备上已安装应用的包名列表。</li></ul></li><li><p><strong>登出</strong></p><ul><li><strong>方法</strong>：<code>fun logout()</code></li><li><strong>说明</strong>：在 Launcher 退出登录时调用。登出后，TPNS 服务器将停止推送消息。</li></ul></li></ul><h3 id="_3-2-消息订阅管理" tabindex="-1"><a class="header-anchor" href="#_3-2-消息订阅管理" aria-hidden="true">#</a> 3.2 消息订阅管理</h3><ul><li><p><strong>订阅消息</strong></p><ul><li><strong>方法</strong>：<code>fun subscribeNotification(installedPkgsList: List&lt;String&gt;)</code></li><li><strong>说明</strong>：在插件应用安装时调用，更新已安装的应用包名列表以接收相应推送消息。</li></ul></li><li><p><strong>取消订阅消息</strong></p><ul><li><strong>方法</strong>：<code>fun unsubscribeNotification(unInstalledPkgsList: List&lt;String&gt;)</code></li><li><strong>说明</strong>：在插件应用卸载时调用，取消对该应用包的消息订阅。</li></ul></li></ul><h3 id="_3-3-通知与协议操作" tabindex="-1"><a class="header-anchor" href="#_3-3-通知与协议操作" aria-hidden="true">#</a> 3.3 通知与协议操作</h3><ul><li><p><strong>获取通知操作实例</strong></p><ul><li><strong>方法</strong>：<code>fun getNotificationOperation(): NotificationUseCase</code></li><li><strong>说明</strong>：返回 <code>NotificationUseCase</code> 实例，用于进行通知消息的插入、查询、分页、标记已读等操作。该接口为只读访问接口，Launcher 外部不允许对内部数据进行写操作。</li></ul></li><li><p><strong>获取协议操作实例</strong></p><ul><li><strong>方法</strong>：<code>fun getProtocolOperation(): ProtocolUseCase</code></li><li><strong>说明</strong>：返回 <code>ProtocolUseCase</code> 实例，提供报文数据的插入、重发和删除功能。一般情况下，Launcher 外部无需调用此 API。</li></ul></li></ul><h3 id="_3-4-通知监听管理" tabindex="-1"><a class="header-anchor" href="#_3-4-通知监听管理" aria-hidden="true">#</a> 3.4 通知监听管理</h3><ul><li><p><strong>添加通知监听器</strong></p><ul><li><strong>方法</strong>：<code>fun addNotificationListener(listener: TPNSNotificationListener)</code></li><li><strong>说明</strong>：新增一个通知监听器，用于实时接收 TPNS 服务器推送的消息。</li></ul></li><li><p><strong>移除通知监听器</strong></p><ul><li><strong>方法</strong>：<code>fun removeNotificationListener(listener: TPNSNotificationListener)</code></li><li><strong>说明</strong>：移除指定的通知监听器，停止对消息的监听。</li></ul></li></ul><hr><h2 id="_4-notificationusecase-接口说明" tabindex="-1"><a class="header-anchor" href="#_4-notificationusecase-接口说明" aria-hidden="true">#</a> 4. NotificationUseCase 接口说明</h2><p><code>NotificationUseCase</code> 主要用于处理通知消息的持久化与查询，其功能包括：</p><h3 id="_4-1-消息插入" tabindex="-1"><a class="header-anchor" href="#_4-1-消息插入" aria-hidden="true">#</a> 4.1 消息插入</h3><ul><li><p><strong>异步插入通知</strong></p><ul><li><strong>方法</strong>：<code>suspend fun insertNotification(event: TPNSProto.NotificationMessageSendEvent)</code></li><li><strong>说明</strong>：将收到的 Protobuf 通知消息转换为实体类后保存到数据库（异步执行）。</li></ul></li><li><p><strong>同步插入通知</strong></p><ul><li><strong>方法</strong>：<code>fun insertNotificationSync(event: TPNSProto.NotificationMessageSendEvent)</code></li><li><strong>说明</strong>：同步保存通知消息到数据库。</li></ul></li></ul><h3 id="_4-2-消息统计与查询" tabindex="-1"><a class="header-anchor" href="#_4-2-消息统计与查询" aria-hidden="true">#</a> 4.2 消息统计与查询</h3><ul><li><p><strong>获取通知消息总数</strong></p><ul><li><strong>方法</strong>： <ul><li>异步版本：<code>suspend fun getNotificationsCount(read: Boolean): Int</code></li><li>同步版本：<code>fun getNotificationsCountSync(read: Boolean): Int</code></li></ul></li><li><strong>说明</strong>：根据是否已读状态，返回符合条件的通知总数。</li></ul></li><li><p><strong>获取通知消息列表</strong></p><ul><li><strong>方法</strong>： <ul><li>异步版本：<code>suspend fun getNotifications(read: Boolean, limit: Int, offset: Int): List&lt;NotificationEntity&gt;</code></li><li>同步版本：<code>fun getNotificationsSync(read: Boolean, limit: Int, offset: Int): List&lt;NotificationEntity&gt;</code></li></ul></li><li><strong>说明</strong>：根据分页参数及是否已读状态，获取通知消息列表。</li></ul></li><li><p><strong>Paging3 分页查询</strong></p><ul><li><strong>方法</strong>：<code>fun getNotificationsPaging(read: Boolean): PagingSource&lt;Int, NotificationEntity&gt;</code></li><li><strong>说明</strong>：利用 Paging3 分页库获取通知消息数据源，适用于需要分页展示的场景。</li></ul></li></ul><h3 id="_4-3-消息状态更新" tabindex="-1"><a class="header-anchor" href="#_4-3-消息状态更新" aria-hidden="true">#</a> 4.3 消息状态更新</h3><ul><li><strong>标记通知为已读</strong><ul><li><strong>方法</strong>： <ul><li>异步版本：<code>suspend fun markNotificationAsRead(fp: String)</code></li><li>同步版本：<code>fun markNotificationAsReadSync(fp: String)</code></li></ul></li><li><strong>说明</strong>：根据通知的唯一标识（fp）更新状态，将其标记为已读。</li></ul></li></ul><h3 id="_4-4-单个通知实体操作" tabindex="-1"><a class="header-anchor" href="#_4-4-单个通知实体操作" aria-hidden="true">#</a> 4.4 单个通知实体操作</h3><ul><li><strong>插入单个通知实体</strong><ul><li><strong>方法</strong>： <ul><li>异步版本：<code>suspend fun insertNotificationEntity(notificationEntity: NotificationEntity)</code></li><li>同步版本：<code>fun insertNotificationEntitySync(notificationEntity: NotificationEntity)</code></li></ul></li><li><strong>说明</strong>：直接插入一个通知实体到数据库中。</li></ul></li></ul><hr><h2 id="_5-protocolusecase-接口说明" tabindex="-1"><a class="header-anchor" href="#_5-protocolusecase-接口说明" aria-hidden="true">#</a> 5. ProtocolUseCase 接口说明</h2><p><code>ProtocolUseCase</code> 主要针对 TPNS 协议报文的管理，其核心功能包括：</p><h3 id="_5-1-插入报文" tabindex="-1"><a class="header-anchor" href="#_5-1-插入报文" aria-hidden="true">#</a> 5.1 插入报文</h3><ul><li><strong>插入一条 Protobuf 报文</strong><ul><li><strong>方法</strong>：<code>suspend fun insertProtocol(fp: String, protocol: ByteArray, sendTime: Long, event: TPNSProto.EventType)</code></li><li><strong>说明</strong>：将报文的唯一标识、报文字节数据、发送时间和事件类型保存到数据库。适用于记录每次发送的推送报文。</li></ul></li></ul><h3 id="_5-2-重发未确认的报文" tabindex="-1"><a class="header-anchor" href="#_5-2-重发未确认的报文" aria-hidden="true">#</a> 5.2 重发未确认的报文</h3><ul><li><strong>重发所有未确认的报文</strong><ul><li><strong>方法</strong>： <code>suspend fun resendAllUnconfirmed(retryActionMapper: Map&lt;TPNSProto.EventType, suspend (ProtocolEntity) -&gt; Unit&gt;)</code></li><li><strong>说明</strong>： <ul><li>遍历所有报文记录，对包含在 <code>retryActionMapper</code> 中的事件类型进行重发操作。</li><li>每次重发后会更新重试次数，并执行映射中对应的操作。</li><li>此接口确保未确认的推送报文能够进行重试，提升消息可靠性。</li></ul></li></ul></li></ul><h3 id="_5-3-删除报文" tabindex="-1"><a class="header-anchor" href="#_5-3-删除报文" aria-hidden="true">#</a> 5.3 删除报文</h3><ul><li><p><strong>根据唯一标识删除报文</strong></p><ul><li><strong>方法</strong>：<code>suspend fun deleteProtocol(fp: String)</code></li><li><strong>说明</strong>：通过报文唯一标识删除相应记录。</li></ul></li><li><p><strong>通过 ACK 报文删除对应报文</strong></p><ul><li><strong>方法</strong>：<code>suspend fun deleteProtocol(event: ByteString)</code></li><li><strong>说明</strong>：解析 ACK 报文（TPNSProto.AckEvent），根据其中的 fp 删除对应的报文记录。</li></ul></li></ul><hr><h2 id="_6-使用示例" tabindex="-1"><a class="header-anchor" href="#_6-使用示例" aria-hidden="true">#</a> 6. 使用示例</h2><p>下面给出一个简单的使用示例，说明如何在 Launcher 中集成 TPNS 客户端 SDK：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token comment">// 引入 TPNS 客户端 SDK</span>
<span class="token keyword">import</span> com<span class="token punctuation">.</span>teamhelper<span class="token punctuation">.</span>bridge<span class="token punctuation">.</span>host<span class="token punctuation">.</span>TPNS
<span class="token keyword">import</span> com<span class="token punctuation">.</span>teamhelper<span class="token punctuation">.</span>bridge<span class="token punctuation">.</span>host<span class="token punctuation">.</span>TPNSNotificationListener
<span class="token keyword">import</span> com<span class="token punctuation">.</span>teamhelper<span class="token punctuation">.</span>bridge<span class="token punctuation">.</span>host<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>usecase<span class="token punctuation">.</span>NotificationUseCase

<span class="token comment">// 假设在 Launcher 登录成功后执行</span>
<span class="token keyword">fun</span> <span class="token function">onLauncherLoginSuccess</span><span class="token punctuation">(</span>userId<span class="token operator">:</span> Long<span class="token punctuation">,</span> token<span class="token operator">:</span> String<span class="token punctuation">,</span> installedPkgsList<span class="token operator">:</span> List<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 登录 TPNS 服务器</span>
    TPNS<span class="token punctuation">.</span><span class="token function">login</span><span class="token punctuation">(</span>userId<span class="token punctuation">,</span> token<span class="token punctuation">,</span> installedPkgsList<span class="token punctuation">)</span>
    
    <span class="token comment">// 订阅通知消息（插件安装时调用）</span>
    TPNS<span class="token punctuation">.</span><span class="token function">subscribeNotification</span><span class="token punctuation">(</span>installedPkgsList<span class="token punctuation">)</span>
    
    <span class="token comment">// 添加通知监听器</span>
    TPNS<span class="token punctuation">.</span><span class="token function">addNotificationListener</span><span class="token punctuation">(</span><span class="token keyword">object</span> <span class="token operator">:</span> TPNSNotificationListener <span class="token punctuation">{</span>
        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onNotificationReceived</span><span class="token punctuation">(</span>message<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 处理收到的通知消息</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;收到通知: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">message</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    
    <span class="token comment">// 示例：查询未读通知数量（异步调用）</span>
    <span class="token comment">// 使用协程进行异步调用</span>
    <span class="token comment">// CoroutineScope(Dispatchers.Main).launch {</span>
    <span class="token comment">//     val count = TPNS.getNotificationOperation().getNotificationsCount(read = false)</span>
    <span class="token comment">//     println(&quot;未读通知数: $count&quot;)</span>
    <span class="token comment">// }</span>
<span class="token punctuation">}</span>

<span class="token comment">// 在退出登录时调用</span>
<span class="token keyword">fun</span> <span class="token function">onLauncherLogout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 移除所有通知监听器（示例）</span>
    <span class="token comment">// TPNS.removeNotificationListener(listener)</span>
    
    <span class="token comment">// 登出 TPNS</span>
    TPNS<span class="token punctuation">.</span><span class="token function">logout</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_7-注意事项" tabindex="-1"><a class="header-anchor" href="#_7-注意事项" aria-hidden="true">#</a> 7. 注意事项</h2><ul><li><strong>初始化顺序</strong>：在 Launcher 登录成功后，必须首先调用 <code>login</code> 接口建立连接，再进行后续的消息订阅与监听操作。</li><li><strong>线程与协程</strong>：部分接口（例如插入通知、查询通知数量、标记已读等）提供了同步与异步版本，建议在主线程中调用异步接口，避免阻塞 UI。</li><li><strong>SDK 内部数据安全</strong>：部分接口（如获取通知和协议操作实例）仅供内部数据只读访问，外部调用时请勿直接修改相关数据。</li></ul>`,51)]))}const c=s(e,[["render",o],["__file","tpns_api.html.vue"]]);export{c as default};
